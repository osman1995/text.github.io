package com.game.test.ui

import android.graphics.Bitmap
import android.webkit.WebView
import android.webkit.WebViewClient
import android.webkit.WebChromeClient
import android.webkit.WebSettings
import android.webkit.WebResourceError
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import android.webkit.SslErrorHandler
import android.net.http.SslError
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.viewinterop.AndroidView
import androidx.compose.ui.unit.dp
import android.os.Build
import android.util.Log
import android.webkit.WebView.setWebContentsDebuggingEnabled
import android.webkit.ConsoleMessage
import android.webkit.JavascriptInterface
import android.view.ViewGroup
import android.view.View
import android.webkit.ValueCallback
import android.webkit.DownloadListener
import android.content.Intent
import android.net.Uri
import android.os.Environment
import android.webkit.MimeTypeMap
import android.content.pm.PackageManager
import android.Manifest
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import java.io.File
import android.app.DownloadManager
import android.content.Context
import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import android.webkit.URLUtil
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.TextButton
import android.widget.Toast
import android.util.Base64
import java.io.FileOutputStream
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.ui.res.painterResource
import com.game.test.R
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.activity.compose.BackHandler
import android.app.Activity
import androidx.compose.foundation.layout.*
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.viewinterop.AndroidView
import androidx.compose.ui.unit.dp
import android.webkit.WebView.setWebContentsDebuggingEnabled
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.TextButton
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.sp
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.ui.res.painterResource
import androidx.activity.compose.BackHandler
import androidx.compose.foundation.background
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.draw.clip
import kotlinx.coroutines.delay
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.IOException
import java.net.HttpURLConnection
import android.webkit.GeolocationPermissions


@Composable
fun AdCountdownWarning(countdown: Int, onCountdownFinished: () -> Unit) {
    var currentCountdown by remember { mutableStateOf(5) }

    LaunchedEffect(Unit) {
        for (i in 5 downTo 1) {
            currentCountdown = i
            delay(1000)
        }
        onCountdownFinished()
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.BottomEnd
    ) {
        Box(
            modifier = Modifier
                .clip(RoundedCornerShape(8.dp))
                .background(Color.Black.copy(alpha = 0.8f))
                .padding(horizontal = 16.dp, vertical = 8.dp)
        ) {
            Text(
                text = "Ads in $currentCountdown seconds",
                color = Color.White,
                fontSize = 16.sp,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
fun WheelSpinScreen(
    modifier: Modifier = Modifier,
    onAdCountdownStart: () -> Unit = {},
    onAdCountdownFinished: () -> Unit = {}
) {
    val context = LocalContext.current
    var isOnline by remember { mutableStateOf<Boolean?>(null) } // null = checking
    var isLoading by remember { mutableStateOf(true) }
    var hasError by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf("") }
    var isErrorMonitoringInjected by remember { mutableStateOf(false) }
    var showPermissionDialog by remember { mutableStateOf(false) }
    var pendingFileUpload by remember { mutableStateOf<ValueCallback<Array<Uri>>?>(null) }
    var lastBackPressTime by remember { mutableStateOf(0L) }
    var webView by remember { mutableStateOf<WebView?>(null) }
    var pendingDownloadInfo by remember { mutableStateOf<Triple<String, String, String>?>(null) } // url, filename, mimeType
    var showAdCountdown by remember { mutableStateOf(false) }
    var countdownValue by remember { mutableStateOf(5) }

    // Countdown effect
    LaunchedEffect(showAdCountdown) {
        if (showAdCountdown) {
            for (i in 5 downTo 1) {
                countdownValue = i
                delay(1000)
            }
            showAdCountdown = false
            onAdCountdownFinished()
        }
    }

    // Function to start countdown
    fun startAdCountdown() {
        showAdCountdown = true
        countdownValue = 5
        onAdCountdownStart()
    }

    // Function to reload the WebView
    fun reloadWebView() {
        webView?.reload()
        hasError = false
        errorMessage = ""
    }

    // Handle back press
    BackHandler {
        val currentTime = System.currentTimeMillis()
        if (currentTime - lastBackPressTime <= 2000) { // 2 seconds threshold
            // Double back press detected, go to home screen
            val homeIntent = Intent(Intent.ACTION_MAIN).apply {
                addCategory(Intent.CATEGORY_HOME)
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(homeIntent)
        } else {
            // First back press
            lastBackPressTime = currentTime
            Toast.makeText(context, "Press back again to exit", Toast.LENGTH_SHORT).show()
        }
    }

    fun isOnlineCompat(context: Context): Boolean {
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        Log.d("DEBUG", "Checking connectivity...")
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val network = cm.activeNetwork ?: return false
            val capabilities = cm.getNetworkCapabilities(network) ?: return false
            capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
        } else {
            @Suppress("DEPRECATION")
            val networkInfo = cm.activeNetworkInfo
            @Suppress("DEPRECATION")
            networkInfo != null && networkInfo.isConnected
        }
    }

    LaunchedEffect(Unit) {
        val result = isOnlineCompat(context)
        Log.d("DEBUG", "isOnlineCompat result: $result")
        isOnline = result
    }

    // File picker launcher using OpenDocument
    val filePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.OpenDocument()
    ) { uri ->
        uri?.let {
            pendingFileUpload?.onReceiveValue(arrayOf(it))
        } ?: run {
            pendingFileUpload?.onReceiveValue(emptyArray())
        }
        pendingFileUpload = null
    }

    // SAF download launcher (no LaunchedEffect, use context directly)
    val createDocumentLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.CreateDocument("*/*")
    ) { uri: Uri? ->
        if (uri != null && pendingDownloadInfo != null) {
            val (url, filename, mimeType) = pendingDownloadInfo!!
            pendingDownloadInfo = null
            
            // Launch coroutine for download
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val outputStream = context.contentResolver.openOutputStream(uri)
                    if (url.startsWith("data:")) {
                        // Handle data URLs (base64)
                        val base64Data = url.substringAfter(",")
                        val data = android.util.Base64.decode(base64Data, android.util.Base64.DEFAULT)
                        outputStream?.write(data)
                    } else {
                        // Download from network
                        val connection = java.net.URL(url).openConnection() as HttpURLConnection
                        
                        // Set common headers that most browsers use
                        connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
                        connection.setRequestProperty("Accept", "*/*")
                        connection.setRequestProperty("Accept-Language", "en-US,en;q=0.9")
                        connection.setRequestProperty("Accept-Encoding", "gzip, deflate, br")
                        connection.setRequestProperty("Connection", "keep-alive")
                        connection.setRequestProperty("Sec-Fetch-Dest", "document")
                        connection.setRequestProperty("Sec-Fetch-Mode", "navigate")
                        connection.setRequestProperty("Sec-Fetch-Site", "none")
                        connection.setRequestProperty("Sec-Fetch-User", "?1")
                        connection.setRequestProperty("Upgrade-Insecure-Requests", "1")
                        
                        // Add referer and origin based on the URL
                        val urlObj = java.net.URL(url)
                        val origin = "${urlObj.protocol}://${urlObj.host}"
                        connection.setRequestProperty("Origin", origin)
                        connection.setRequestProperty("Referer", origin)
                        
                        connection.setRequestMethod("GET")
                        connection.setInstanceFollowRedirects(true)
                        connection.connect()
                        
                        if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                            val inputStream = connection.inputStream
                            inputStream.use { input ->
                                outputStream?.use { output ->
                                    input.copyTo(output)
                                }
                            }
                        } else if (connection.responseCode == HttpURLConnection.HTTP_FORBIDDEN) {
                            // Try alternative download method for 403 errors
                            val alternativeConnection = java.net.URL(url).openConnection() as HttpURLConnection
                            alternativeConnection.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
                            alternativeConnection.setRequestProperty("Accept", "*/*")
                            alternativeConnection.setRequestProperty("Accept-Language", "en-US,en;q=0.9")
                            alternativeConnection.setRequestProperty("Connection", "keep-alive")
                            alternativeConnection.setRequestProperty("Range", "bytes=0-")
                            alternativeConnection.setRequestMethod("GET")
                            alternativeConnection.setInstanceFollowRedirects(true)
                            alternativeConnection.connect()
                            
                            if (alternativeConnection.responseCode in 200..299) {
                                val inputStream = alternativeConnection.inputStream
                                inputStream.use { input ->
                                    outputStream?.use { output ->
                                        input.copyTo(output)
                                    }
                                }
                            } else {
                                throw IOException("Server returned response code: ${alternativeConnection.responseCode}")
                            }
                        } else {
                            throw IOException("Server returned response code: ${connection.responseCode}")
                        }
                    }
                    outputStream?.close()
                    
                    // Show success message on main thread
                    withContext(Dispatchers.Main) {
                        Toast.makeText(context, "File saved successfully!", Toast.LENGTH_SHORT).show()
                    }
                } catch (e: Exception) {
                    Log.e("Download", "Download failed", e)
                    // Show error message on main thread
                    withContext(Dispatchers.Main) {
                        Toast.makeText(context, "Download failed: ${e.message ?: "Unknown error"}", Toast.LENGTH_SHORT).show()
                    }
                }
            }
        } else {
            pendingDownloadInfo = null
        }
    }

    when (isOnline) {
        null -> { // Still checking
            Box(
                modifier = Modifier.fillMaxSize().background(Color.White),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = Color.Black)
            }
        }
        false -> { // Offline
            var retryTrigger by remember { mutableStateOf(0) }
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .background(Color(0xFFD69C6A)),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                Image(
                    painter = painterResource(id = R.drawable.background),
                    contentDescription = "No Internet Background",
                    modifier = Modifier
                        .fillMaxWidth(0.2f)
                        .aspectRatio(1f)
                )
                Spacer(modifier = Modifier.height(32.dp))
                Image(
                    painter = painterResource(id = R.drawable.button),
                    contentDescription = "Try Again Button",
                    modifier = Modifier
                        .fillMaxWidth(0.07f)
                        .aspectRatio(1f)
                        .clickable(
                            indication = null,
                            interactionSource = remember { MutableInteractionSource() }
                        ) {
                            retryTrigger++
                        }
                )
            }
            LaunchedEffect(retryTrigger) {
                if (isOnlineCompat(context)) {
                    isOnline = true
                }
            }
        }
        true -> {
            Box(modifier = modifier.fillMaxSize()) {
                AndroidView(
                    modifier = Modifier.fillMaxSize(),
                    factory = { context ->
                        WebView(context).apply {
                            webView = this
                            // Add JavaScript interface for error handling
                            addJavascriptInterface(object {
                                @JavascriptInterface
                                fun logError(error: String) {
                                    Log.e("WebView", "JavaScript Error: $error")
                                }
                            }, "Android")

                            // Register the JavaScript interface
                            addJavascriptInterface(WebAppInterface(context), "AndroidDownloader")

                            // Set download listener
                            setDownloadListener { url, userAgent, contentDisposition, mimeType, contentLength ->
                                try {
                                    // Get the filename from content disposition or URL
                                    var filename = URLUtil.guessFileName(url, contentDisposition, mimeType)
                                    
                                    // If no filename could be determined, use a default name with timestamp
                                    if (filename.isNullOrEmpty() || filename == "downloadfile") {
                                        val extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType) ?: "bin"
                                        filename = "download_${System.currentTimeMillis()}.$extension"
                                    }

                                    // For blob: URLs, inject JS to get base64 data
                                    if (url.startsWith("blob:")) {
                                        val jsCode = """
                                            (function() {
                                                var xhr = new XMLHttpRequest();
                                                xhr.open('GET', '$url', true);
                                                xhr.responseType = 'blob';
                                                xhr.onload = function() {
                                                    var reader = new FileReader();
                                                    reader.onloadend = function() {
                                                        var base64data = reader.result.split(',')[1];
                                                        window.AndroidDownloader.saveBase64File(base64data, '$filename', '$mimeType');
                                                    };
                                                    reader.readAsDataURL(xhr.response);
                                                };
                                                xhr.send();
                                            })();
                                        """.trimIndent()
                                        this.evaluateJavascript(jsCode, null)
                                        return@setDownloadListener
                                    }

                                    // For normal URLs, use SAF
                                    pendingDownloadInfo = Triple(url, filename, mimeType ?: "*/*")
                                    createDocumentLauncher.launch(filename)
                                } catch (e: Exception) {
                                    Log.e("WebView", "Download error: ", e)
                                    Toast.makeText(context, "Download failed: ${e.message ?: "Unknown error"}", Toast.LENGTH_SHORT).show()
                                }
                            }

                            webViewClient = object : WebViewClient() {
                                override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
                                    super.onPageStarted(view, url, favicon)
                                    isLoading = true
                                    hasError = false
                                    isErrorMonitoringInjected = false
                                    Log.d("WebView", "Page started loading: $url")
                                }

                                override fun onPageFinished(view: WebView?, url: String?) {
                                    super.onPageFinished(view, url)
                                    isLoading = false
                                    Log.d("WebView", "Page finished loading: $url")
                                    
                                    // Only inject error monitoring once
                                    if (!isErrorMonitoringInjected) {
                                        view?.evaluateJavascript("""
                                            (function() {
                                                if (window.__errorMonitoringInjected) return;
                                                window.__errorMonitoringInjected = true;
                                                
                                                // Global error handler
                                                window.onerror = function(message, source, lineno, colno, error) {
                                                    Android.logError(JSON.stringify({
                                                        message: message,
                                                        source: source,
                                                        lineno: lineno,
                                                        colno: colno,
                                                        error: error ? error.toString() : 'undefined'
                                                    }));
                                                    return false;
                                                };
                                                
                                                // Unhandled promise rejection handler
                                                window.addEventListener('unhandledrejection', function(event) {
                                                    Android.logError(JSON.stringify({
                                                        type: 'unhandledrejection',
                                                        reason: event.reason ? event.reason.toString() : 'undefined'
                                                    }));
                                                });
                                            })();
                                        """.trimIndent(), null)
                                        isErrorMonitoringInjected = true
                                    }
                                }

                                override fun onReceivedError(
                                    view: WebView?,
                                    request: WebResourceRequest?,
                                    error: WebResourceError?
                                ) {
                                    super.onReceivedError(view, request, error)
                                    // Only show error for main frame requests
                                    if (request?.isForMainFrame == true) {
                                        val errorDesc = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                                            error?.description ?: "Unknown error"
                                        } else {
                                            "Error loading page"
                                        }
                                        
                                        // Check if it's a network error
                                        if (errorDesc.contains("net::err_failed")) {
                                            // Don't show error for network failures, just log it
                                            Log.w("WebView", "Network error detected: $errorDesc")
                                            // Try to reload after a short delay
                                            view?.postDelayed({
                                                if (isOnlineCompat(context)) {
                                                    view.reload()
                                                }
                                            }, 2000)
                                        } else {
                                            hasError = true
                                            errorMessage = "Error loading page: $errorDesc"
                                            Log.e("WebView", "Error loading page: $errorDesc")
                                        }
                                    }
                                    isLoading = false
                                }

                                override fun onReceivedSslError(
                                    view: WebView?,
                                    handler: SslErrorHandler?,
                                    error: SslError?
                                ) {
                                    Log.w("WebView", "SSL Error: ${error?.primaryError}")
                                    handler?.proceed()
                                }

                                override fun shouldInterceptRequest(
                                    view: WebView?,
                                    request: WebResourceRequest?
                                ): WebResourceResponse? {
                                    val url = request?.url?.toString() ?: ""
                                    if (url.contains("relay-event.talkie-ai.com")) {
                                        Log.w("WebView", "CORS request detected: $url")
                                    }
                                    return super.shouldInterceptRequest(view, request)
                                }

                                override fun shouldOverrideUrlLoading(view: WebView?, request: WebResourceRequest?): Boolean {
                                    val url = request?.url.toString()
                                    return if (url.startsWith("http://") || url.startsWith("https://")) {
                                        false // Let WebView handle it
                                    } else {
                                        try {
                                            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
                                            context.startActivity(intent)
                                        } catch (e: Exception) {
                                            Log.e("WebView", "No app can handle this url: $url")
                                        }
                                        true // We handled it
                                    }
                                }
                            }

                            webChromeClient = object : WebChromeClient() {
                                override fun onConsoleMessage(consoleMessage: ConsoleMessage?): Boolean {
                                    val message = consoleMessage?.message() ?: ""
                                    val source = consoleMessage?.sourceId() ?: ""
                                    val lineNumber = consoleMessage?.lineNumber() ?: 0
                                    
                                    // WebGL performance monitoring
                                    if (message.contains("WebGL") || message.contains("Unity")) {
                                        Log.d("WebView", "WebGL/Unity: $message (at $source:$lineNumber)")
                                    }
                                    
                                    when {
                                        message.contains("TikTok Pixel") -> {
                                            Log.w("WebView", "TikTok Pixel issue: $message (at $source:$lineNumber)")
                                        }
                                        message.contains("CORS") -> {
                                            Log.w("WebView", "CORS issue: $message (at $source:$lineNumber)")
                                        }
                                        message.contains("get exclusive cards error") -> {
                                            Log.e("WebView", "Exclusive cards error: $message (at $source:$lineNumber)")
                                        }
                                        message.contains("npc_info") -> {
                                            Log.e("WebView", "NPC info error: $message (at $source:$lineNumber)")
                                        }
                                        message.contains("GSI_LOGGER") -> {
                                            Log.w("WebView", "Google Sign-In warning: $message (at $source:$lineNumber)")
                                        }
                                        else -> {
                                            Log.d("WebView", "Console: $message (at $source:$lineNumber)")
                                        }
                                    }
                                    return super.onConsoleMessage(consoleMessage)
                                }

                                // Handle geolocation requests
                                override fun onGeolocationPermissionsShowPrompt(
                                    origin: String?,
                                    callback: GeolocationPermissions.Callback?
                                ) {
                                    callback?.invoke(origin, true, false)
                                }

                                // Handle fullscreen mode
                                override fun onShowCustomView(view: View?, callback: CustomViewCallback?) {
                                    super.onShowCustomView(view, callback)
                                    // Handle fullscreen mode if needed
                                }

                                override fun onHideCustomView() {
                                    super.onHideCustomView()
                                    // Exit fullscreen mode if needed
                                }

                                // Handle file chooser
                                override fun onShowFileChooser(
                                    webView: WebView?,
                                    filePathCallback: ValueCallback<Array<Uri>>?,
                                    fileChooserParams: FileChooserParams?
                                ): Boolean {
                                    pendingFileUpload = filePathCallback
                                    filePickerLauncher.launch(arrayOf("*/*"))
                                    return true
                                }

                                // Block pop-ups
                                override fun onCreateWindow(
                                    view: WebView?,
                                    isDialog: Boolean,
                                    isUserGesture: Boolean,
                                    resultMsg: android.os.Message?
                                ): Boolean {
                                    return false
                                }
                            }

                            // --- WebView Performance Optimizations for HTML Games ---
                            // Always use hardware acceleration for best graphics performance
                            setLayerType(WebView.LAYER_TYPE_HARDWARE, null)

                            settings.apply {
                                javaScriptEnabled = true
                                domStorageEnabled = true
                                cacheMode = WebSettings.LOAD_DEFAULT
                                allowFileAccess = true
                                allowContentAccess = true
                                useWideViewPort = true
                                loadWithOverviewMode = true
                                builtInZoomControls = false
                                displayZoomControls = false
                                setSupportZoom(false)
                                mediaPlaybackRequiresUserGesture = false
                                
                                // Critical performance settings
                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                                    mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
                                    // Enable smooth transitions
                                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                                        setEnableSmoothTransition(true)
                                        safeBrowsingEnabled = false // Disable safe browsing for better performance
                                    }
                                }
                                
                                // Universal access and cache settings
                                allowUniversalAccessFromFileURLs = true
                                allowFileAccessFromFileURLs = true
                                
                                // Disable unnecessary features
                                setGeolocationEnabled(false)
                                setSupportMultipleWindows(false)
                                setNeedInitialFocus(false) // Disable initial focus for better performance
                                
                                // Configure cache with size limit
                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                                    setCacheMode(WebSettings.LOAD_DEFAULT)
                                }
                                
                                // Enable hardware acceleration
                                setLayerType(WebView.LAYER_TYPE_HARDWARE, null)
                                
                                // Enable database storage
                                databaseEnabled = true
                                
                                // Set a modern user agent with Unity WebGL support
                                userAgentString = "Mozilla/5.0 (Linux; Android 10; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36 UnityWebGL"
                            }
                            
                            // System-level performance optimizations
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                                (context as? Activity)?.window?.apply {
                                    addFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
                                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                                        setSustainedPerformanceMode(true)
                                    }
                                    // Immersive gaming mode
                                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                                        decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                                                or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                                                or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                                                or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                                                or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                                                or View.SYSTEM_UI_FLAG_FULLSCREEN)
                                    }
                                }
                            }
                            
                            // WebView container optimizations
                            isHorizontalScrollBarEnabled = false
                            isVerticalScrollBarEnabled = false
                            overScrollMode = View.OVER_SCROLL_NEVER
                            
                            // Set layout parameters to optimize rendering
                            layoutParams = ViewGroup.LayoutParams(
                                ViewGroup.LayoutParams.MATCH_PARENT,
                                ViewGroup.LayoutParams.MATCH_PARENT
                            )
                            
                            // Enhanced WebGL and Unity optimizations
                            evaluateJavascript("""
                                (function() {
                                    // Enhanced WebGL context optimization
                                    const originalGetContext = HTMLCanvasElement.prototype.getContext;
                                    HTMLCanvasElement.prototype.getContext = function(contextType, attributes) {
                                        if (contextType === 'webgl' || contextType === 'experimental-webgl') {
                                            attributes = attributes || {};
                                            attributes.alpha = false;
                                            attributes.antialias = false;
                                            attributes.powerPreference = 'high-performance';
                                            attributes.preserveDrawingBuffer = false;
                                            attributes.stencil = false;
                                            attributes.depth = true;
                                            attributes.desynchronized = true;
                                            attributes.lowLatency = true;
                                            attributes.xrCompatible = false; // Disable XR for better performance
                                            attributes.failIfMajorPerformanceCaveat = false;
                                            attributes.premultipliedAlpha = false;
                                            attributes.antialias = false;
                                        }
                                        return originalGetContext.call(this, contextType, attributes);
                                    };

                                    // Pre-load WebGL extensions for gaming
                                    function preloadWebGLExtensions() {
                                        const canvas = document.createElement('canvas');
                                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                                        if (gl) {
                                            // Pre-load common gaming extensions
                                            const extensions = [
                                                'OES_vertex_array_object',
                                                'WEBKIT_WEBGL_compressed_texture_s3tc',
                                                'WEBGL_compressed_texture_s3tc',
                                                'WEBGL_compressed_texture_etc',
                                                'WEBGL_compressed_texture_etc1',
                                                'WEBGL_compressed_texture_pvrtc',
                                                'WEBGL_compressed_texture_astc',
                                                'OES_texture_float',
                                                'OES_texture_half_float',
                                                'WEBGL_depth_texture',
                                                'OES_element_index_uint',
                                                'EXT_texture_filter_anisotropic'
                                            ];
                                            
                                            extensions.forEach(ext => {
                                                try {
                                                    gl.getExtension(ext);
                                                } catch (e) {
                                                    console.log('Extension not supported:', ext);
                                                }
                                            });
                                        }
                                    }

                                    // Device performance detection and FPS throttling
                                    let targetFPS = 60;
                                    let lastFrameTime = performance.now();
                                    let frameCount = 0;
                                    let batteryOptimized = false;
                                    
                                    function detectDevicePerformance() {
                                        // Check if device is in battery saver mode
                                        if (navigator.getBattery) {
                                            navigator.getBattery().then(battery => {
                                                batteryOptimized = battery.charging === false && battery.level < 0.2;
                                                if (batteryOptimized) {
                                                    targetFPS = 30; // Lower FPS for battery optimization
                                                }
                                            });
                                        }
                                        
                                        // Check device memory if available
                                        if (navigator.deviceMemory) {
                                            if (navigator.deviceMemory < 4) {
                                                targetFPS = 30; // Lower FPS for low memory devices
                                            }
                                        }
                                        
                                        // Check if device is in low power mode
                                        if (navigator.hardwareConcurrency) {
                                            if (navigator.hardwareConcurrency < 4) {
                                                targetFPS = 30; // Lower FPS for low CPU devices
                                            }
                                        }
                                    }
                                    
                                    function monitorAndThrottleFPS() {
                                        const now = performance.now();
                                        frameCount++;
                                        
                                        if (now - lastFrameTime >= 1000) {
                                            const currentFPS = frameCount;
                                            frameCount = 0;
                                            lastFrameTime = now;
                                            
                                            // Adjust quality based on FPS
                                            if (currentFPS < targetFPS * 0.9) {
                                                qualityLevel = Math.max(0.5, qualityLevel - 0.1);
                                                adjustQuality(qualityLevel);
                                            } else if (currentFPS > targetFPS * 1.1 && !batteryOptimized) {
                                                qualityLevel = Math.min(1.0, qualityLevel + 0.1);
                                                adjustQuality(qualityLevel);
                                            }
                                        }
                                        
                                        requestAnimationFrame(monitorAndThrottleFPS);
                                    }
                                    
                                    // Initialize final optimizations
                                    preloadWebGLExtensions();
                                    detectDevicePerformance();
                                    monitorAndThrottleFPS();
                                    
                                    // Unity-specific optimizations
                                    if (window.unityInstance) {
                                        // Set Unity quality level based on device performance
                                        window.unityInstance.SetQualityLevel(batteryOptimized ? 2 : 3);
                                        
                                        // Enable Unity WebGL optimizations
                                        window.unityInstance.Module.HEAPU8.buffer = new ArrayBuffer(1024 * 1024 * 100);
                                    }
                                })();
                            """.trimIndent(), null)
                            
                            // Enhanced WebViewClient with game asset prioritization
                            webViewClient = object : WebViewClient() {
                                override fun shouldInterceptRequest(
                                    view: WebView?,
                                    request: WebResourceRequest?
                                ): WebResourceResponse? {
                                    val url = request?.url?.toString() ?: ""
                                    
                                    // Prioritize game assets
                                    if (url.endsWith(".wasm") || url.endsWith(".data") || 
                                        url.endsWith(".unity3d") || url.endsWith(".mem")) {
                                        
                                        // Set high priority headers
                                        val headers = mapOf(
                                            "Priority" to "high",
                                            "X-Requested-With" to "UnityWebGL",
                                            "Accept" to "*/*",
                                            "Accept-Encoding" to "gzip, deflate, br",
                                            "Cache-Control" to "max-age=86400" // 24-hour cache
                                        )
                                        
                                        // Detect MIME type
                                        val mimeType = when {
                                            url.endsWith(".wasm") -> "application/wasm"
                                            url.endsWith(".data") -> "application/octet-stream"
                                            url.endsWith(".unity3d") -> "application/octet-stream"
                                            url.endsWith(".mem") -> "application/octet-stream"
                                            else -> "application/octet-stream"
                                        }
                                        
                                        return WebResourceResponse(
                                            mimeType,
                                            "UTF-8",
                                            200,
                                            "OK",
                                            headers,
                                            null
                                        )
                                    }
                                    
                                    return super.shouldInterceptRequest(view, request)
                                }
                                
                                override fun onReceivedError(
                                    view: WebView?,
                                    request: WebResourceRequest?,
                                    error: WebResourceError?
                                ) {
                                    super.onReceivedError(view, request, error)
                                    // Enhanced error handling for graphics-intensive content
                                    if (request?.isForMainFrame == true) {
                                        val errorDesc = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                                            error?.description ?: "Unknown error"
                                        } else {
                                            "Error loading page"
                                        }
                                        
                                        // Handle specific WebGL errors
                                        when {
                                            errorDesc.contains("net::err_failed") -> {
                                                Log.w("WebView", "Network error detected: $errorDesc")
                                                view?.postDelayed({
                                                    if (isOnlineCompat(context)) {
                                                        view.reload()
                                                    }
                                                }, 2000)
                                            }
                                            errorDesc.contains("WebGL") -> {
                                                Log.e("WebView", "WebGL error: $errorDesc")
                                                // Attempt to recover WebGL context
                                                view?.evaluateJavascript("""
                                                    (function() {
                                                        const canvases = document.querySelectorAll('canvas');
                                                        canvases.forEach(canvas => {
                                                            const gl = canvas.getContext('webgl');
                                                            if (gl) {
                                                                gl.getExtension('WEBGL_lose_context')?.restoreContext();
                                                            }
                                                        });
                                                    })();
                                                """.trimIndent(), null)
                                            }
                                            else -> {
                                                hasError = true
                                                errorMessage = "Error loading page: $errorDesc"
                                                Log.e("WebView", "Error loading page: $errorDesc")
                                            }
                                        }
                                    }
                                    isLoading = false
                                }
                            }
                            
                            // Load the URL
                            loadUrl("https://html5.gamedistribution.com/rvvASMiM/22e4de5183c44d4a91a2e78858948f6a/index.html?gd_sdk_referrer_url=https%3A%2F%2Fwww.y8.com%2Fgames%2F&key=y8&value=default&gd_zone_config=eyJwYXJlbnRVUkwiOiJodHRwczovL2h0bWw1LmdhbWVkaXN0cmlidXRpb24uY29tL2QyYWFhM2JhZDdkNjQxNDFiNTQ1YzkxM2UxMDU2ZTdiLz9nZF9zZGtfcmVmZXJyZXJfdXJsPWh0dHBzOi8vd3d3Lnk4LmNvbS9nYW1lcy8ma2V5PXk4JnZhbHVlPWRlZmF1bHQiLCJwYXJlbnREb21haW4iOiJ5OC5jb20iLCJ0b3BEb21haW4iOiJ5OC5jb20iLCJoYXNJbXByZXNzaW9uIjpmYWxzZSwibG9hZGVyRW5hYmxlZCI6dHJ1ZSwiaG9zdCI6Imh0bWw1LmdhbWVkaXN0cmlidXRpb24uY29tIiwidmVyc2lvbiI6IjEuNS4xNiJ9")

                            // Clear cache and history
                            clearHistory()
                        }
                    }
                )

                // Show error message if there is an error
                if (hasError) {
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .background(Color.Black.copy(alpha = 0.5f)),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.Center
                        ) {
                            Text(
                                text = errorMessage,
                                color = Color.White,
                                modifier = Modifier.padding(16.dp)
                            )
                            Spacer(modifier = Modifier.height(16.dp))
                            Button(
                                onClick = { reloadWebView() }
                            ) {
                                Text("Retry")
                            }
                        }
                    }
                }

                // Permission dialog
                if (showPermissionDialog) {
                    AlertDialog(
                        onDismissRequest = { 
                            showPermissionDialog = false
                            pendingFileUpload?.onReceiveValue(emptyArray())
                            pendingFileUpload = null
                        },
                        title = { Text("Storage Permission Required") },
                        text = { Text("This app needs storage permission to upload files. Please grant the permission to continue.") },
                        confirmButton = {
                            Button(onClick = {
                                showPermissionDialog = false
                                // Launch file picker directly
                                filePickerLauncher.launch(arrayOf("*/*"))
                            }) {
                                Text("Grant Permission")
                            }
                        },
                        dismissButton = {
                            TextButton(onClick = {
                                showPermissionDialog = false
                                pendingFileUpload?.onReceiveValue(emptyArray())
                                pendingFileUpload = null
                            }) {
                                Text("Cancel")
                            }
                        }
                    )
                }
            }
        }
    }
}

// JavaScript interface to save base64 files from WebView
class WebAppInterface(private val context: Context) {
    @JavascriptInterface
    fun saveBase64File(base64Data: String, fileName: String, mimeType: String) {
        // Use SAF: prompt user to pick location, then save
        (context as? Activity)?.runOnUiThread {
            // Use a global or static reference to trigger the Compose launcher if needed
            Toast.makeText(context, "Please use the download button to save files.", Toast.LENGTH_LONG).show()
        }
    }
} 
